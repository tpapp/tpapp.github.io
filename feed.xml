<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Tamás K. Papp  ]]>
    </title>
    <link> https://tamaspapp.eu </link>
    <description>
      <![CDATA[  website  ]]>
    </description>
    <atom:link
      href="https://tamaspapp.eu/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Approximating a function using derivatives  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/hermite-approximation-spectralkit/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/hermite-approximation-spectralkit/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>When simulating from an economic model, I had to approximate a function \(f(x; \theta): [0,1] \to [0,1]\) for a variety of \(\theta\)s. \(f\) itself has to be solved for numerically, but otherwise it is pretty friendly, being continuous and increasing, with \(f(0)=0\) and \(f(1)=1\).</p>
<p>After profiling, this turned out to be the most costly part, so I had to approximate it. Since I needed derivatives \(f'(x)\), I was wondering whether making the approximation match them &#40;known as a <a href="https://en.wikipedia.org/wiki/Hermite_interpolation">Hermite interpolation</a>&#41; would increase accuracy.</p>
<p>The &#40;pedagogical, unoptimized&#41; code below sums up the gist of my numerical experiments, with <code>f</code> below standing in for my implicitly solved function. It also demonstrates the new features of <a href="https://github.com/tpapp/SpectralKit.jl/">SpectralKit.jl</a> <code>v0.10</code>.</p>
<p>First, we set up the problem:</p>
<pre><code class="language-julia">using SpectralKit, PGFPlotsX, DisplayAsf&#40;x&#41; &#61; &#40;exp&#40;x&#41; - 1&#41; / &#40;exp&#40;1&#41; - 1&#41;
f′&#40;x&#41; &#61; exp&#40;x&#41; / &#40;exp&#40;1&#41; - 1&#41;
const I &#61; BoundedLinear&#40;0, 1&#41;   # interval we map from</code></pre>
<p>Then define an interpolation using <code>N</code> Chebyshev nodes, matching the values.</p>
<pre><code class="language-julia">function interpolation0&#40;f, N&#41;
    basis &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N&#41;
    ϕ &#61; collocation_matrix&#40;basis&#41; \ map&#40;f ∘ from_pm1&#40;I&#41;, grid&#40;basis&#41;&#41;
    linear_combination&#40;basis, ϕ&#41; ∘ to_pm1&#40;I&#41;
end;</code></pre>
<p>Same exercise, but with the derivatives too, so we need two bases, one with double the number of functions &#40;so we need to make sure <code>N</code> is even&#41;, while we just use <code>N/2</code> for the nodes.</p>
<pre><code class="language-julia">function interpolation01&#40;f, f′, N&#41;
    @assert iseven&#40;N&#41;
    basis1 &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N ÷ 2&#41; # nodes from this one
    basis2 &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N&#41;     # evaluate on this basis
    x &#61; from_pm1.&#40;I, grid&#40;basis1&#41;&#41;            # map nodes from &#91;-1,1&#93;
    M &#61; collocation_matrix&#40;basis2, to_pm1.&#40;I, derivatives.&#40;x&#41;&#41;&#41;
    ϕ &#61; vcat&#40;map&#40;y -&gt; y&#91;0&#93;, M&#41;, map&#40;y -&gt; y&#91;1&#93;, M&#41;&#41; \ vcat&#40;f.&#40;x&#41;, f′.&#40;x&#41;&#41;
    linear_combination&#40;basis2, ϕ&#41; ∘ to_pm1&#40;I&#41;
end;</code></pre>
<p>Importantly, note that mapping to &#91;-1,1&#93; for the collocation matrix has to be preceded by lifting to derivatives.</p>
<p>Then calculate the max abs difference, in digits &#40;<code>log10</code>&#41;.</p>
<pre><code class="language-julia">function log10_max_abs_diff&#40;f, f̂; M &#61; 1000&#41;
    x &#61; range&#40;0, 1; length &#61; M&#41;
    log10&#40;maximum&#40;@. abs&#40;f&#40;x&#41; - f̂&#40;x&#41;&#41;&#41;&#41;
end;</code></pre>
<p>Then let&#39;s explore the errors in values ...</p>
<pre><code class="language-julia">Ns &#61; 4:2:20
errors &#61; &#91;&#40;log10_max_abs_diff&#40;f, interpolation0&#40;f, N&#41;&#41;,
           log10_max_abs_diff&#40;f, interpolation01&#40;f, f′, N&#41;&#41;&#41;
          for N in Ns&#93;</code></pre>
<pre><code class="language-julia">9-element Vector&#123;Tuple&#123;Float64, Float64&#125;&#125;:
 &#40;-3.1996028783051695, -2.594513489315976&#41;
 &#40;-5.882145733021446, -5.488666848393999&#41;
 &#40;-8.835160643191552, -8.232779398084544&#41;
 &#40;-11.994023867372805, -11.44897859894945&#41;
 &#40;-15.176438519807359, -14.664555158828485&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;
 &#40;-15.255619765854984, -15.35252977886304&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;</code></pre>
<p>... and derivatives.</p>
<pre><code class="language-julia">d_errors &#61; &#91;&#40;log10_max_abs_diff&#40;f′, &#40;x -&gt; x&#91;1&#93;&#41; ∘ interpolation0&#40;f, N&#41; ∘ derivatives&#41;,
             log10_max_abs_diff&#40;f′, &#40;x -&gt; x&#91;1&#93;&#41; ∘ interpolation01&#40;f, f′, N&#41; ∘ derivatives&#41;&#41;
            for N in Ns&#93;</code></pre>
<pre><code class="language-julia">9-element Vector&#123;Tuple&#123;Float64, Float64&#125;&#125;:
 &#40;-2.0758500387125216, -2.093336352131656&#41;
 &#40;-4.549339116162139, -4.611253272379436&#41;
 &#40;-7.363367596306161, -7.429305371299876&#41;
 &#40;-10.417554370684012, -10.485171320264207&#41;
 &#40;-13.381718167990524, -13.689771947181466&#41;
 &#40;-13.834015838985154, -14.374806173574193&#41;
 &#40;-14.03551167781493, -14.539616422220185&#41;
 &#40;-13.724140848812729, -14.750469787535078&#41;
 &#40;-13.714040521908403, -14.724140848812729&#41;</code></pre>
<p>Finally the plots:</p>
<pre><code class="language-julia">@pgf Axis&#40;&#123; xlabel &#61; &quot;number of basis functions&quot;,
            ylabel &#61; &quot;log10 abs error in values&quot;,
            legend_cell_align&#61; &quot;left&quot; &#125;,
          PlotInc&#40;Table&#40;Ns, first.&#40;errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values&quot;&#41;,
          PlotInc&#40;Table&#40;Ns, last.&#40;errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values and derivatives&quot;&#41;&#41; |&gt; DisplayAs.SVG</code></pre>
<p><img src="2197788484.svg" alt="" /></p>
<pre><code class="language-julia">@pgf Axis&#40;&#123; xlabel &#61; &quot;number of basis functions&quot;,
            ylabel &#61; &quot;log10 abs error in values&quot;,
            legend_cell_align&#61; &quot;left&quot; &#125;,
          PlotInc&#40;Table&#40;Ns, first.&#40;d_errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values&quot;&#41;,
          PlotInc&#40;Table&#40;Ns, last.&#40;d_errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values and derivatives&quot;&#41;&#41; |&gt; DisplayAs.SVG</code></pre>
<p><img src="3226471975.svg" alt="" /></p>
<p>The conclusion is that even without matching them explicitly, derivatives are well-approximated. Getting an extra digit of accuracy in derivatives above 12–14 nodes means sacrificing a digit of accuracy with a low number of nodes. 14 seems to be the break-even point here, but then we are at machine precision anyway.</p>
<p>As usual, simply approximating with Chebyshev polynomials is extremely accurate in itself for practical purposes, even when derivatives are needed. Of course, this depends on the function being “nice”.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="hermite-approximation-spectralkit_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Tables output with Literate.jl  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/markdown-tables/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/markdown-tables/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>I recently wrote a very lightweight package called <a href="https://github.com/tpapp/MarkdownTables.jl">MarkdownTables.jl</a> that makes it easy to embed tables using Literate.jl. It handles anything that works with <a href="https://tables.juliadata.org">Tables.jl</a>:</p>
<pre><code class="language-julia">using MarkdownTables
my_table &#61; &#91;&#40;animal &#61; &quot;cat&quot;, legs &#61; 4&#41;,
            &#40;animal &#61; &quot;catfish&quot;, legs &#61; 0&#41;,
            &#40;animal &#61; &quot;canary&quot;, legs &#61; 2&#41;&#93;
my_table |&gt; markdown_table&#40;&#41;</code></pre>
<table><tr><th align="right">animal</th><th align="right">legs</th></tr><tr><td align="right">cat</td><td align="right">4</td></tr><tr><td align="right">catfish</td><td align="right">0</td></tr><tr><td align="right">canary</td><td align="right">2</td></tr></table>
<p>Under the hood, it just wraps some basic Markdown with <a href="https://github.com/tkf/DisplayAs.jl">DisplayAs.jl</a>:</p>
<pre><code class="language-julia">my_table |&gt; markdown_table&#40;String&#41; |&gt; print</code></pre>
<pre><code class="language-julia">| animal  | legs |
|---------|------|
|     cat |    4 |
| catfish |    0 |
|  canary |    2 |</code></pre>
<p>The default output is pretty basic — while the function has some options for formatting, it is recommended that you use CSS instead.</p>
<p>I expect that this pretty much rounds out the tooling I need for blogging with <a href="https://franklinjl.org/">Franklin.jl</a>. Feedback and PRs are of course welcome, but I intend to keep this package very basic.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="markdown-tables_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Reproducible examples in blog posts  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/09-14-reproducible-examples/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/09-14-reproducible-examples/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>When migrating this blog recently from Hugo to Franklin.jl, the main difficulty I faced was reproducing old examples &#40;so effectively I didn&#39;t rerun anything, and just moved the old generated HTML pages&#41;. I have been bothered by this for a long time, so I wrote a quick hack which I packaged up in <a href="https://github.com/tpapp/ReproducibleLiteratePage.jl">ReproducibleLiteratePage.jl</a>.</p>
<p>This page was processed using that package. Here is how it works:</p>
<ol>
<li><p>take a Julia code file marked up with <a href="https://fredrikekre.github.io/Literate.jl/">Literate.jl</a>,</p>
</li>
<li><p>add a <code>Project.toml</code> and a <code>Manifest.toml</code> &#40;eg activate the directory as a project and add packages&#41;</p>
</li>
<li><p>produce a markdown file using <code>ReproducibleLiteratePage.compile_directory&#40;&#41;</code>.</p>
</li>
</ol>
<p>Here is some code:</p>
<pre><code class="language-julia">using UnPack # the lightest package I could think of
struct Foo
    a
    b
end
@unpack a, b &#61; Foo&#40;1, 2&#41;
a, b</code></pre>
<pre><code class="language-julia">&#40;1, 2&#41;</code></pre>
<p>The Julia source &#40;again, marked up with Literate.jl&#41;, <code>Project.toml</code>, and <code>Manifest.toml</code> should be available as a <code>tar</code> archive at the bottom of the page.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="09-14-reproducible-examples_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Migration from Hugo to Franklin.jl  ]]>
  </title>
  <link>  </link>
  <guid>  </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>After a long break, I am restarting my blog. In addition to personal reasons, the main reason I did not keep it up is that I found <a href="https://gohugo.io/">Hugo</a> a bit difficult to work with: updates to Hugo required updates to my setup, and integration with Julia was less than ideal. I have now switched to <a href="https://franklinjl.org/">Franklin.jl</a>.</p>
<p>I do not have the time to convert all my earlier posts, they remain available in <a href="../../../../post/">this directory</a>. I hope that this will keep old links working, if there is a problem please let me know and I will try to fix it.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>
</channel></rss>