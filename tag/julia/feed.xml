<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Tamás K. Papp  ]]>
    </title>
    <link> https://tamaspapp.eu </link>
    <description>
      <![CDATA[  website  ]]>
    </description>
    <atom:link
      href="https://tamaspapp.eu/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Tables output with Literate.jl  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/markdown-tables/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/markdown-tables/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>I recently wrote a very lightweight package called <a href="https://github.com/tpapp/MarkdownTables.jl">MarkdownTables.jl</a> that makes it easy to embed tables using Literate.jl. It handles anything that works with <a href="https://tables.juliadata.org">Tables.jl</a>:</p>
<pre><code class="language-julia">using MarkdownTables
my_table &#61; &#91;&#40;animal &#61; &quot;cat&quot;, legs &#61; 4&#41;,
            &#40;animal &#61; &quot;catfish&quot;, legs &#61; 0&#41;,
            &#40;animal &#61; &quot;canary&quot;, legs &#61; 2&#41;&#93;
my_table |&gt; markdown_table&#40;&#41;</code></pre>
<table><tr><th align="right">animal</th><th align="right">legs</th></tr><tr><td align="right">cat</td><td align="right">4</td></tr><tr><td align="right">catfish</td><td align="right">0</td></tr><tr><td align="right">canary</td><td align="right">2</td></tr></table>
<p>Under the hood, it just wraps some basic Markdown with <a href="https://github.com/tkf/DisplayAs.jl">DisplayAs.jl</a>:</p>
<pre><code class="language-julia">my_table |&gt; markdown_table&#40;String&#41; |&gt; print</code></pre>
<pre><code class="language-julia">| animal  | legs |
|---------|------|
|     cat |    4 |
| catfish |    0 |
|  canary |    2 |</code></pre>
<p>The default output is pretty basic — while the function has some options for formatting, it is recommended that you use CSS instead.</p>
<p>I expect that this pretty much rounds out the tooling I need for blogging with <a href="https://franklinjl.org/">Franklin.jl</a>. Feedback and PRs are of course welcome, but I intend to keep this package very basic.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="markdown-tables_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  TransformVariables.jl gets pretty printing  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2023/02-22-transformvariables-pretty-printing/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2023/02-22-transformvariables-pretty-printing/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>A recent update &#40;version 0.8.2&#41; to <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a> adds pretty printing of &#40;nested&#41; transformations. Eg what used to be</p>
<pre><code class="language-julia">julia&gt; using StaticArrays, TransformVariablesjulia&gt; t &#61; as&#40;&#40;a &#61; asℝ₊, b &#61; as&#40;Array, asℝ₋, 3, 3&#41;,
               c &#61; corr_cholesky_factor&#40;13&#41;,
               d &#61; as&#40;&#40;asℝ, corr_cholesky_factor&#40;SMatrix&#123;3,3&#125;&#41;,
                       UnitSimplex&#40;3&#41;, UnitVector&#40;4&#41;&#41;&#41;&#41;&#41;
TransformVariables.TransformTuple&#123;NamedTuple&#123;&#40;:a, :b, :c, :d&#41;, Tuple&#123;TransformVariables.ShiftedExp&#123;true, Int64&#125;, TransformVariables.ArrayTransformation&#123;TransformVariables.ShiftedExp&#123;false, Int64&#125;, 2&#125;, CorrCholeskyFactor, TransformVariables.TransformTuple&#123;Tuple&#123;TransformVariables.Identity, TransformVariables.StaticCorrCholeskyFactor&#123;3, 3&#125;, UnitSimplex, UnitVector&#125;&#125;&#125;&#125;&#125;&#40;&#40;a &#61; asℝ₊, b &#61; TransformVariables.ArrayTransformation&#123;TransformVariables.ShiftedExp&#123;false, Int64&#125;, 2&#125;&#40;asℝ₋, &#40;3, 3&#41;&#41;, c &#61; CorrCholeskyFactor&#40;13&#41;, d &#61; TransformVariables.TransformTuple&#123;Tuple&#123;TransformVariables.Identity, TransformVariables.StaticCorrCholeskyFactor&#123;3, 3&#125;, UnitSimplex, UnitVector&#125;&#125;&#40;&#40;asℝ, TransformVariables.StaticCorrCholeskyFactor&#123;3, 3&#125;&#40;&#41;, UnitSimplex&#40;3&#41;, UnitVector&#40;4&#41;&#41;, 9&#41;&#41;, 97&#41;</code></pre>
<p>which is a single line of 700&#43; characters &#40;which your browser mercifully hides behind a scrollbar&#41;, we now have</p>
<pre><code class="language-julia">julia&gt; using StaticArrays, TransformVariables
&#91; Info: Precompiling TransformVariables &#91;84d833dd-6860-57f9-a1a7-6da5db126cff&#93;julia&gt; t &#61; as&#40;&#40;a &#61; asℝ₊, b &#61; as&#40;Array, asℝ₋, 3, 3&#41;,
                      c &#61; corr_cholesky_factor&#40;13&#41;,
                      d &#61; as&#40;&#40;asℝ, corr_cholesky_factor&#40;SMatrix&#123;3,3&#125;&#41;,
                              UnitSimplex&#40;3&#41;, UnitVector&#40;4&#41;&#41;&#41;&#41;&#41;
&#91;1:97&#93; NamedTuple of transformations
  &#91;1:1&#93; :a → asℝ₊
  &#91;2:10&#93; :b → 3×3×asℝ₋ &#40;dimension 1&#41;
  &#91;11:88&#93; :c → 13×13 correlation cholesky factor
  &#91;89:97&#93; :d → Tuple of transformations
    &#91;98:98&#93; 1 → asℝ
    &#91;108:110&#93; 2 → SMatrix&#123;3,3&#125; correlation cholesky factor
    &#91;120:121&#93; 3 → 3 element unit simplex transformation
    &#91;131:133&#93; 4 → 4 element unit vector transformation</code></pre>
<p>which tells you which indices map to which part of the result.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Approximating a function using derivatives  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/hermite-approximation-spectralkit/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/hermite-approximation-spectralkit/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>When simulating from an economic model, I had to approximate a function \(f(x; \theta): [0,1] \to [0,1]\) for a variety of \(\theta\)s. \(f\) itself has to be solved for numerically, but otherwise it is pretty friendly, being continuous and increasing, with \(f(0)=0\) and \(f(1)=1\).</p>
<p>After profiling, this turned out to be the most costly part, so I had to approximate it. Since I needed derivatives \(f'(x)\), I was wondering whether making the approximation match them &#40;known as a <a href="https://en.wikipedia.org/wiki/Hermite_interpolation">Hermite interpolation</a>&#41; would increase accuracy.</p>
<p>The &#40;pedagogical, unoptimized&#41; code below sums up the gist of my numerical experiments, with <code>f</code> below standing in for my implicitly solved function. It also demonstrates the new features of <a href="https://github.com/tpapp/SpectralKit.jl/">SpectralKit.jl</a> <code>v0.10</code>.</p>
<p>First, we set up the problem:</p>
<pre><code class="language-julia">using SpectralKit, PGFPlotsX, DisplayAsf&#40;x&#41; &#61; &#40;exp&#40;x&#41; - 1&#41; / &#40;exp&#40;1&#41; - 1&#41;
f′&#40;x&#41; &#61; exp&#40;x&#41; / &#40;exp&#40;1&#41; - 1&#41;
const I &#61; BoundedLinear&#40;0, 1&#41;   # interval we map from</code></pre>
<p>Then define an interpolation using <code>N</code> Chebyshev nodes, matching the values.</p>
<pre><code class="language-julia">function interpolation0&#40;f, N&#41;
    basis &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N&#41;
    ϕ &#61; collocation_matrix&#40;basis&#41; \ map&#40;f ∘ from_pm1&#40;I&#41;, grid&#40;basis&#41;&#41;
    linear_combination&#40;basis, ϕ&#41; ∘ to_pm1&#40;I&#41;
end;</code></pre>
<p>Same exercise, but with the derivatives too, so we need two bases, one with double the number of functions &#40;so we need to make sure <code>N</code> is even&#41;, while we just use <code>N/2</code> for the nodes.</p>
<pre><code class="language-julia">function interpolation01&#40;f, f′, N&#41;
    @assert iseven&#40;N&#41;
    basis1 &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N ÷ 2&#41; # nodes from this one
    basis2 &#61; Chebyshev&#40;EndpointGrid&#40;&#41;, N&#41;     # evaluate on this basis
    x &#61; from_pm1.&#40;I, grid&#40;basis1&#41;&#41;            # map nodes from &#91;-1,1&#93;
    M &#61; collocation_matrix&#40;basis2, to_pm1.&#40;I, derivatives.&#40;x&#41;&#41;&#41;
    ϕ &#61; vcat&#40;map&#40;y -&gt; y&#91;0&#93;, M&#41;, map&#40;y -&gt; y&#91;1&#93;, M&#41;&#41; \ vcat&#40;f.&#40;x&#41;, f′.&#40;x&#41;&#41;
    linear_combination&#40;basis2, ϕ&#41; ∘ to_pm1&#40;I&#41;
end;</code></pre>
<p>Importantly, note that mapping to &#91;-1,1&#93; for the collocation matrix has to be preceded by lifting to derivatives.</p>
<p>Then calculate the max abs difference, in digits &#40;<code>log10</code>&#41;.</p>
<pre><code class="language-julia">function log10_max_abs_diff&#40;f, f̂; M &#61; 1000&#41;
    x &#61; range&#40;0, 1; length &#61; M&#41;
    log10&#40;maximum&#40;@. abs&#40;f&#40;x&#41; - f̂&#40;x&#41;&#41;&#41;&#41;
end;</code></pre>
<p>Then let&#39;s explore the errors in values ...</p>
<pre><code class="language-julia">Ns &#61; 4:2:20
errors &#61; &#91;&#40;log10_max_abs_diff&#40;f, interpolation0&#40;f, N&#41;&#41;,
           log10_max_abs_diff&#40;f, interpolation01&#40;f, f′, N&#41;&#41;&#41;
          for N in Ns&#93;</code></pre>
<pre><code class="language-julia">9-element Vector&#123;Tuple&#123;Float64, Float64&#125;&#125;:
 &#40;-3.1996028783051695, -2.594513489315976&#41;
 &#40;-5.882145733021446, -5.488666848393999&#41;
 &#40;-8.835160643191552, -8.232779398084544&#41;
 &#40;-11.994023867372805, -11.44897859894945&#41;
 &#40;-15.176438519807359, -14.664555158828485&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;
 &#40;-15.255619765854984, -15.35252977886304&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;
 &#40;-15.35252977886304, -15.35252977886304&#41;</code></pre>
<p>... and derivatives.</p>
<pre><code class="language-julia">d_errors &#61; &#91;&#40;log10_max_abs_diff&#40;f′, &#40;x -&gt; x&#91;1&#93;&#41; ∘ interpolation0&#40;f, N&#41; ∘ derivatives&#41;,
             log10_max_abs_diff&#40;f′, &#40;x -&gt; x&#91;1&#93;&#41; ∘ interpolation01&#40;f, f′, N&#41; ∘ derivatives&#41;&#41;
            for N in Ns&#93;</code></pre>
<pre><code class="language-julia">9-element Vector&#123;Tuple&#123;Float64, Float64&#125;&#125;:
 &#40;-2.0758500387125216, -2.093336352131656&#41;
 &#40;-4.549339116162139, -4.611253272379436&#41;
 &#40;-7.363367596306161, -7.429305371299876&#41;
 &#40;-10.417554370684012, -10.485171320264207&#41;
 &#40;-13.381718167990524, -13.689771947181466&#41;
 &#40;-13.834015838985154, -14.374806173574193&#41;
 &#40;-14.03551167781493, -14.539616422220185&#41;
 &#40;-13.724140848812729, -14.750469787535078&#41;
 &#40;-13.714040521908403, -14.724140848812729&#41;</code></pre>
<p>Finally the plots:</p>
<pre><code class="language-julia">@pgf Axis&#40;&#123; xlabel &#61; &quot;number of basis functions&quot;,
            ylabel &#61; &quot;log10 abs error in values&quot;,
            legend_cell_align&#61; &quot;left&quot; &#125;,
          PlotInc&#40;Table&#40;Ns, first.&#40;errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values&quot;&#41;,
          PlotInc&#40;Table&#40;Ns, last.&#40;errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values and derivatives&quot;&#41;&#41; |&gt; DisplayAs.SVG</code></pre>
<p><img src="2197788484.svg" alt="" /></p>
<pre><code class="language-julia">@pgf Axis&#40;&#123; xlabel &#61; &quot;number of basis functions&quot;,
            ylabel &#61; &quot;log10 abs error in values&quot;,
            legend_cell_align&#61; &quot;left&quot; &#125;,
          PlotInc&#40;Table&#40;Ns, first.&#40;d_errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values&quot;&#41;,
          PlotInc&#40;Table&#40;Ns, last.&#40;d_errors&#41;&#41;&#41;,
          LegendEntry&#40;&quot;fitting values and derivatives&quot;&#41;&#41; |&gt; DisplayAs.SVG</code></pre>
<p><img src="3226471975.svg" alt="" /></p>
<p>The conclusion is that even without matching them explicitly, derivatives are well-approximated. Getting an extra digit of accuracy in derivatives above 12–14 nodes means sacrificing a digit of accuracy with a low number of nodes. 14 seems to be the break-even point here, but then we are at machine precision anyway.</p>
<p>As usual, simply approximating with Chebyshev polynomials is extremely accurate in itself for practical purposes, even when derivatives are needed. Of course, this depends on the function being “nice”.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="hermite-approximation-spectralkit_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Reproducible examples in blog posts  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2022/09-14-reproducible-examples/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2022/09-14-reproducible-examples/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>When migrating this blog recently from Hugo to Franklin.jl, the main difficulty I faced was reproducing old examples &#40;so effectively I didn&#39;t rerun anything, and just moved the old generated HTML pages&#41;. I have been bothered by this for a long time, so I wrote a quick hack which I packaged up in <a href="https://github.com/tpapp/ReproducibleLiteratePage.jl">ReproducibleLiteratePage.jl</a>.</p>
<p>This page was processed using that package. Here is how it works:</p>
<ol>
<li><p>take a Julia code file marked up with <a href="https://fredrikekre.github.io/Literate.jl/">Literate.jl</a>,</p>
</li>
<li><p>add a <code>Project.toml</code> and a <code>Manifest.toml</code> &#40;eg activate the directory as a project and add packages&#41;</p>
</li>
<li><p>produce a markdown file using <code>ReproducibleLiteratePage.compile_directory&#40;&#41;</code>.</p>
</li>
</ol>
<p>Here is some code:</p>
<pre><code class="language-julia">using UnPack # the lightest package I could think of
struct Foo
    a
    b
end
@unpack a, b &#61; Foo&#40;1, 2&#41;
a, b</code></pre>
<pre><code class="language-julia">&#40;1, 2&#41;</code></pre>
<p>The Julia source &#40;again, marked up with Literate.jl&#41;, <code>Project.toml</code>, and <code>Manifest.toml</code> should be available as a <code>tar</code> archive at the bottom of the page.</p>
<p>
<div class="source_footer">
 This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.<br />Download <a href="09-14-reproducible-examples_source.tar">the source, project, and manifest</a>. 
</div>
</p>
 ]]>
  </content:encoded>
    
  <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  My farewell to <code>@unpack</code>  ]]>
  </title>
  <link> https://tamaspapp.eu/pages/blog/2025/farewell-to-unpack/index.html </link>
  <guid> https://tamaspapp.eu/pages/blog/2025/farewell-to-unpack/index.html </guid>
  <description>
    <![CDATA[  .  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<p>First, a bit of Julia history. When <a href="https://github.com/mauro3/Parameters.jl/">Parameters.jl</a> introduced the <code>@unpack</code> macro in 2015, it scratched an imporant itch for Julia users at the time, especially those coming from &#40;Common&#41; Lisp who were used to <a href="https://novaspec.org/cl/f_with-slots"><code>cl:with-slots</code></a> and similar macros. Given any object with properties, say <code>foo</code> and <code>bar</code>, one could bring them into scope with</p>
<pre><code class="language-julia">@unpack foo, bar &#61; x</code></pre>
<p>instead of a clumsy</p>
<pre><code class="language-julia">foo &#61; x.foo
bar &#61; x.bar</code></pre>
<p>The functionality was so useful that it was later &#40;around 2019&#41; factored out into its own tiny package, <a href="https://github.com/mauro3/UnPack.jl">UnPack.jl</a>. </p>
<p>Of course the Julia developers recognized how great this feature was, and Julia 1.7 &#40;in 2021&#41; brought us the property destructuring syntax</p>
<pre><code class="language-julia">&#40;; foo, bar&#41; &#61; x</code></pre>
<p>But since 1.7 was not an LTS, many packages did not require that version and kept relying on <code>@unpack</code>. In 2023, <a href="https://github.com/devmotion/SimpleUnPack.jl &quot;SimpleUnPack.jl&quot;">SimpleUnPack.jl</a> was written as a drop-in replacement for the most common use case while being easier on the compiler.</p>
<p>Since Julia 1.10 is an LTS,  I am gradually removing <code>@unpack</code> from my packages whenever I happen to refactor them. This is, strictly speaking, not necessary &#40;it would just work forever&#41;, but I like to simplify code when I happen to refactor it for some other reason. I am taking this opportunity to reflect on how useful it was.</p>
<p>There are quite a few lessons there about software development in general, and specifically for Julia:</p>
<ol>
<li><p>Macros are amazingly powerful. No wonder that Lisp users consider them a killer feature, they can extend the language with very useful syntax at essentially zero runtime and negligible compile time cost. It was a great decision for Julia to include them.</p>
</li>
<li><p>The best way to extend a language with new features is to first implement them as a package. This allows experimentation and quick turnaround, leading to a polished end product that the language can include.</p>
</li>
<li><p>Once your Julia code works, it will keep working for a long time, potentially forever in 1.x land.  UnPack.jl <a href="https://juliahub.com/ui/Packages/General/UnPack">still has 200 dependents</a>. This allows developers to make upgrades at their own pace, prioritizing more urgent issues.</p>
</li>
</ol>
<h3 id="bonus_feature">Bonus feature</h3>
<p>This little Emacs snippet does the conversion from <code>@unpack ...</code> to <code>&#40;; ...&#41;</code>, also working on multiline code etc, either on standalone files or whole packages opened in <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html"><code>dired</code></a>.</p>
<pre><code class="language-emacs-lis">&#40;defun my-julia-remove-unpack &#40;&#41;
  &quot;Go from &#96;@unpack&#39; to &#96;&#40;; ...&#41;&#96; destructuring syntax. Works in dired mode and buffer.&quot;
  &#40;interactive&#41;
  &#40;let* &#40;&#40;from &#40;rx &quot;@unpack&quot;
                   &#40;one-or-more space&#41;
                   &#40;or &#40;seq &quot;&#40;&quot; &#40;group-n 1 &#40;one-or-more &#40;not &quot;@&quot;&#41;&#41;&#41; &quot;&#41;&quot;&#41;
                       &#40;group-n 1 &#40;one-or-more &#40;not &#40;or ?@ ?\n&#41;&#41;&#41;&#41;
                       &#41;
                   &#40;one-or-more space&#41;
                   &quot;&#61;&quot;&#41;&#41;
         &#40;to &quot;&#40;; \\1&#41; &#61;&quot;&#41;&#41;
    &#40;cond
     &#40;&#40;eq major-mode &#39;julia-mode&#41; &#40;query-replace-regexp from to&#41;&#41;
     &#40;&#40;eq major-mode &#39;dired-mode&#41; &#40;dired-do-query-replace-regexp from to&#41;&#41;
     &#40;t &#40;message &quot;Don&#39;t know what to do with mode &#37;s&quot; major-mode&#41;&#41;&#41;&#41;&#41;</code></pre>
<h3 id="ps">P.S.</h3>
<p>&#40;I am reviving my blog after a long break.&#41;</p>
 ]]>
  </content:encoded>
    
  <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Tamás K. Papp</atom:name>
  </atom:author>
        
</item>
</channel></rss>